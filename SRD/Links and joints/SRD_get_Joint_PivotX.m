% Function for getting an SRD Joint - an object, implementing functionality
% of joints, mainly - forward kinematics (via updates of the absolute
% orientation of the link, attached to the joint) and control map
% generation (via ???) 
%
% Name - unique ID of the joint
%
% ChildLink - (handle of an SRD link) link, attached to the joint.
%
% ParentLink - (handle of an SRD link) link, to which the joint is
% attached.
%
% ParentFollowerNumber - (integer) index of the column in the parent link's
% follower; corresponding follower column will be treated as the point
% where the joint is attached
%
% UsedGeneralizedCoordinates - (integer or array of integers) indicies of
% the generalized coordinates that are used to update the joint. PivotX has
% one gen. coordinate that defines the joint angle, while an Euler angle
% floating body joint would have 6 - 3 position component, 3
% orientation/Euler angle components.
%
% UsedControlInputs - (integer or array of integers) indicies of
% the control inputs that are used to control the joint. PivotX has
% one control input that defines the joint torque, while a PivotXY would
% have two inputs
%
% DefaultJointOrientation - (3x3 rotation matrix) orientation offset.
% The RelativeOrientation field of a link attached to a PivotX is
% calculated as RO = DefaultJointOrientation * SRD_RotationMatrix3D_x(q)
%
function Joint = SRD_get_Joint_PivotX(varargin)

Parser = inputParser;
Parser.FunctionName = 'SRD_get_Joint_PivotX';
Parser.addOptional('Name', []);

Parser.addOptional('ChildLink', []);
Parser.addOptional('ParentLink', []);
Parser.addOptional('ParentFollowerNumber', []);

Parser.addOptional('UsedGeneralizedCoordinates', []);
Parser.addOptional('UsedControlInputs', []);

Parser.addOptional('DefaultJointOrientation', []);
Parser.parse(varargin{:});

Joint = SRD_Joint;

Joint.Type = 'PivotX';

Joint.Name            = Parser.Results.Name;
Joint.ChildLink       = Parser.Results.ChildLink;
Joint.ParentLink      = Parser.Results.ParentLink;

Joint.ChildLink.ParentLink            = Joint.ParentLink;
Joint.ChildLink.ParentFollowerNumber  = Parser.Results.ParentFollowerNumber;
Joint.ChildLink.Joint                 = Joint;

Joint.UsedGeneralizedCoordinates      = Parser.Results.UsedGeneralizedCoordinates;
Joint.UsedControlInputs               = Parser.Results.UsedControlInputs;

Joint.DefaultJointOrientation         = Parser.Results.DefaultJointOrientation;


Joint.ChildLink.Update = @(Input) Update(Joint.ChildLink, Input);

Joint.ActionUpdate     = @(Input) ActionUpdate(Joint, Input);

    function Update(Link, Input)
        q = Input(Link.Joint.UsedGeneralizedCoordinates);
        
        Link.RelativeOrientation =  Link.Joint.DefaultJointOrientation * SRD_RotationMatrix3D_x(q);
        
        SRD_ForwardKinematics_JointUpdate_RelativeOrientationType(Link);
    end

    function generalized_force = ActionUpdate(Joint, Input)
        u = Input(Joint.UsedControlInputs);
        
        Child_T = Joint.ChildLink.AbsoluteOrientation;
        
        %this is because torque_child is expressed in the relative
        %coordinates, while jacobians are in the absolute ones
        torque_child  = Child_T * [u; 0; 0];
        torque_parent = Child_T * [-u; 0; 0];
        
        %get angular velocity jacobians
        Child_Jw = Joint.ChildLink.Jacobian_AngularVelocity;
        Parent_Jw = Joint.ParentLink.Jacobian_AngularVelocity;
        
        %find generalized forces generated by the actuator
        gen_force_child  = Child_Jw'  * torque_child;
        gen_force_parent = Parent_Jw' * torque_parent;
        
        generalized_force = gen_force_child + gen_force_parent;
    end

end
