%See documentation for PivotX (SRD_get_Joint_PivotX)
%
%This link directly assigns Link.AbsoluteBase via gen.coordinates, but
%allows to set Link.AbsoluteOrientation as a pure function of the 3
%angles (if the link's parent is Groud or another link with
%constant orientation) or a function of 3 angles and other gen.
%coordinates, if the parent had a non-constant orientation
%
function Joint = SRD_get_Joint_FloatingBaseEuler_XYZ(varargin)

Parser = inputParser;
Parser.FunctionName = 'SRD_get_Joint_FloatingBaseEuler_XYZ';
Parser.addOptional('Name', []);

Parser.addOptional('ChildLink', []);
Parser.addOptional('ParentLink', []);
Parser.addOptional('ParentFollowerNumber', []);

Parser.addOptional('UsedGeneralizedCoordinates', []);
Parser.addOptional('UsedControlInputs', []);

Parser.addOptional('DefaultJointOrientation', []);
Parser.parse(varargin{:});

Joint = SRD_Joint;

Joint.Type = 'FloatingBaseEuler_XYZ';

Joint.Name            = Parser.Results.Name;
Joint.ChildLink       = Parser.Results.ChildLink;
Joint.ParentLink      = Parser.Results.ParentLink;

Joint.ChildLink.ParentLink            = Joint.ParentLink;
Joint.ChildLink.ParentFollowerNumber  = Parser.Results.ParentFollowerNumber;
Joint.ChildLink.Joint                 = Joint;

Joint.UsedGeneralizedCoordinates      = Parser.Results.UsedGeneralizedCoordinates;
Joint.UsedControlInputs               = Parser.Results.UsedControlInputs;

Joint.DefaultJointOrientation         = Parser.Results.DefaultJointOrientation;


Joint.ChildLink.Update = @(Input) Update(Joint.ChildLink, Input);

Joint.ActionUpdate     = @(Input) ActionUpdate(Joint, Input);

    function Update(Link, Input)
        q = Input(Link.Joint.UsedGeneralizedCoordinates);
        
        Tx = SRD_RotationMatrix3D_x(q(1));
        Ty = SRD_RotationMatrix3D_y(q(2));
        Tz = SRD_RotationMatrix3D_z(q(3));
        
        Link.RelativeOrientation = Tz*Ty*Tx;
        
        Link.AbsoluteBase = [q(4); q(5); q(6)];
        Link.AbsoluteOrientation = Link.ParentLink.AbsoluteOrientation * Link.RelativeOrientation;
        
        rBaseToFollower = Link.RelativeFollower - repmat(Link.RelativeBase, 1, size(Link.RelativeFollower, 2));
        rBaseToCoM      = Link.RelativeCoM - Link.RelativeBase;
        
        Link.AbsoluteFollower = repmat(Link.AbsoluteBase, 1, size(Link.RelativeFollower, 2)) + Link.AbsoluteOrientation*rBaseToFollower;
        Link.AbsoluteCoM = Link.AbsoluteBase + Link.AbsoluteOrientation*rBaseToCoM;
        
    end

    function generalized_force = ActionUpdate(Joint, Input)
       
        error('not implemented!')
        
        u = Input(Joint.UsedControlInputs);
        
        Child_T = Joint.ChildLink.AbsoluteOrientation;
        
        %this is because torque_child is expressed in the relative
        %coordinates, while jacobians are in the absolute ones
        torque_child  = Child_T * [u; 0; 0];
        torque_parent = Child_T * [-u; 0; 0];
        
        %get angular velocity jacobians
        Child_Jw = Joint.ChildLink.Jacobian_AngularVelocity;
        Parent_Jw = Joint.ParentLink.Jacobian_AngularVelocity;
        
        %find generalized forces generated by the actuator
        gen_force_child  = Child_Jw'  * torque_child;
        gen_force_parent = Parent_Jw' * torque_parent;
        
        generalized_force = gen_force_child + gen_force_parent;
    end

end

























